<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Admin Dashboard - Senen</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f4f4;
      margin: 0;
    }

    .header {
      background: #000;
      padding: 10px 0;
      text-align: center;
      position: relative;
    }

    .header img {
      height: 30px;
    }

    .container {
      padding: 0 15px;
    }

    /* TAB STYLING */
    .tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin-bottom: 20px;
    }

    .tab {
      padding: 10px 20px;
      cursor: pointer;
      background: #f4f4f4;
      border: 1px solid #ccc;
      border-bottom: none;
      margin-right: 5px;
      border-radius: 5px 5px 0 0;
      transition: all 0.3s ease;
    }

    .tab.active {
      background: white;
      border-bottom: 1px solid white;
      margin-bottom: -1px;
      font-weight: bold;
      color: #000;
      background-color: #fff;
    }

    .tab:hover:not(.active) {
      background-color: #e0e0e0;
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* PRODUCTS TAB STYLING */
    form {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 20px;
    }

    .form-row {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 15px;
      width: 100%;
    }

    input,
    button,
    textarea,
    select {
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ccc;
      border-radius: 10px;
    }

    input[type="text"],
    input[type="number"],
    input[type="file"],
    input[type="password"],
    textarea,
    select {
      flex: 1;
      min-width: 200px;
    }

    textarea {
      min-height: 100px;
      resize: vertical;
    }

    .submit-btn-container {
      width: 100%;
      display: flex;
      justify-content: flex-end;
    }

    .submit-btn-container button {
      background: black;
      color: white;
      border: none;
      cursor: pointer;
      padding: 10px 20px;
      border-radius: 10px;
      max-width: 200px;
    }

    table {
      background: white;
      width: 100%;
      max-width: 98%;
      border-collapse: collapse;
      margin: auto;
      margin-bottom: 20px;
      border-radius: 10px;
      overflow: hidden;
    }

    th,
    td {
      padding: 10px;
      border: 1px solid #ccc;
      text-align: center;
    }

    .image-names {
      max-width: 200px;
      word-wrap: break-word;
    }

    .action-buttons {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .icon-btn {
      background-color: black;
      color: white;
      border: none;
      border-radius: 50%;
      padding: 8px 10px;
      font-size: 14px;
      cursor: pointer;
    }

    /* Image preview styling */
    .image-preview-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      width: 100%;
      margin-top: 10px;
    }

    .preview-image {
      position: relative;
      width: 100px;
      height: 100px;
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
    }

    .preview-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .preview-image .remove-btn {
      position: absolute;
      top: 5px;
      right: 5px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .preview-image .move-handle {
      position: absolute;
      bottom: 5px;
      left: 5px;
      background: rgba(0, 0, 0, 0.5);
      color: white;
      border: none;
      border-radius: 50%;
      width: 20px;
      height: 20px;
      cursor: move;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }

    .preview-image.dragging {
      opacity: 0.5;
    }

    /* ORDERS TAB STYLING */
    .order-filters {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      padding: 0 10px;
    }

    .order-filters select,
    .order-filters button {
      padding: 8px 12px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }

    .order-filters button {
      background: black;
      color: white;
      border: none;
      cursor: pointer;
    }

    .orders-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 20px;
      padding: 10px;
    }

    .order-card {
      background: white;
      border-radius: 10px;
      padding: 15px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    .order-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid #eee;
    }

    .order-id {
      font-weight: bold;
      color: #333;
    }

    .order-date {
      color: #666;
      font-size: 0.9em;
    }

    .order-status {
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 0.8em;
      font-weight: bold;
      text-transform: uppercase;
    }

    .status-pending {
      background: #FFF3CD;
      color: #856404;
    }

    .status-created {
      background: #D1ECF1;
      color: #0C5460;
    }

    .status-shipped {
      background: #D4EDDA;
      color: #155724;
    }

    .status-delivered {
      background: #D4EDDA;
      color: #155724;
    }

    .order-details {
      margin: 10px 0;
    }

    .order-details p {
      margin: 5px 0;
      font-size: 0.9em;
    }

    .order-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }

    .status-select {
      flex-grow: 1;
      margin-right: 10px;
    }

    .view-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .view-btn img {
      transition: transform 0.2s;
    }

    .view-btn:hover img {
      transform: scale(1.1);
    }

    /* MODAL STYLING */
    .modal {
      display: none;
      position: fixed;
      z-index: 999;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      justify-content: center;
      align-items: center;
    }

    .modal-content {
      background: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      width: 90%;
      max-width: 300px;
    }

    .modal-content p {
      font-size: 16px;
      margin-bottom: 20px;
    }

    .modal-buttons {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }

    .modal-buttons button {
      flex: 1;
      padding: 10px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: bold;
    }

    .confirm-btn {
      background-color: black;
      color: white;
    }

    .cancel-btn {
      background-color: #ccc;
      color: black;
    }

    /* ORDER DETAILS STYLES */
    .order-info {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .info-section {
      background: #f9f9f9;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }

    .product-section {
      display: flex;
      gap: 20px;
      margin-top: 15px;
    }

    .product-images {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .product-image {
      max-width: 100%;
      max-height: 200px;
      object-fit: contain;
      border: 1px solid #eee;
      border-radius: 8px;
    }

    .product-details {
      flex: 2;
    }

    .status-badge {
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      text-transform: uppercase;
    }

    /* LOADING INDICATOR */
    .loading {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1001;
      justify-content: center;
      align-items: center;
      color: white;
      font-size: 24px;
    }

    .logout-btn {
      position: absolute;
      top: 10px;
      right: 15px;
      background: none;
      border: none;
      cursor: pointer;
      padding: 5px;
    }

    .logout-icon {
      width: 24px;
      height: 24px;
      filter: invert(100%);
    }

    #restoreForm {
      background: white;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    #restoreForm h3 {
      margin-top: 0;
      color: #333;
    }

    #restoreForm .submit-btn-container {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
    }

    #restoreForm .submit-btn-container button {
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
    }

    #restoreForm .submit-btn-container .confirm-btn {
      background: black;
      color: white;
      border: none;
    }

    #restoreForm .submit-btn-container .cancel-btn {
      background: black;
      color: white;
      border: none;
    }


    /* Restore Form Styles */
    .restore-form {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      max-width: 800px;
      margin: 0 auto;
    }

    .restore-form h3 {
      margin-top: 0;
      margin-bottom: 20px;
      color: #333;
      font-size: 1.5rem;
    }

    .form-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group.full-width {
      grid-column: span 2;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
      color: #555;
    }

    .form-control {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #f9f9f9;
      box-sizing: border-box;
    }

    textarea.form-control {
      min-height: 100px;
      resize: vertical;
    }

    .image-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      gap: 10px;
      padding: 10px;
      background: #f5f5f5;
      border-radius: 4px;
      border: 1px dashed #ddd;
    }

    .form-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
    }

    .btn {
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      border: none;
      transition: background 0.2s;
    }

    .btn-primary {
      background: #000;
      color: white;
    }

    .btn-primary:hover {
      background: #333;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
    }

    /* Responsive Adjustments */
    @media (max-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .form-group.full-width {
        grid-column: span 1;
      }

      .form-actions {
        flex-direction: column;
      }

      .btn {
        width: 100%;
      }
    }

    @media (max-width: 768px) {
      .form-row {
        flex-direction: column;
      }

      .submit-btn-container {
        justify-content: center;
      }

      table,
      th,
      td {
        font-size: 14px;
      }

      .orders-grid {
        grid-template-columns: 1fr;
      }

      .order-info {
        grid-template-columns: 1fr;
      }

      .product-section {
        flex-direction: column;
      }

      .order-filters {
        flex-direction: column;
      }
    }
  </style>
</head>

<body>
  <div class="header">
    <img src="kosans-demo.regular.webp" alt="SENEN Logo" />
  </div>

  <div class="loading" id="loadingIndicator">
    Processing, please wait...
  </div>

  <div class="container">
    <div class="tabs">
      <div class="tab active" onclick="switchTab('products')">Products</div>
      <div class="tab" onclick="switchTab('orders')">Orders</div>
      <div class="tab" onclick="switchTab('deleted')">Deleted Products</div>
    </div>

    <!-- PRODUCTS TAB -->
    <div id="products-tab" class="tab-content active">
      <h2>Add New Product</h2>
      <form onsubmit="saveProduct(event)">
        <div class="form-row">
          <input type="text" id="name" placeholder="Product Name" required />
          <input type="number" id="price" placeholder="Price (INR)" required />
          <input type="file" id="image" multiple accept="image/*" required />
        </div>
        <div class="form-row">
          <div id="imagePreview" class="image-preview-container"></div>
        </div>
        <div class="form-row">
          <textarea id="description" placeholder="Product Description" required></textarea>
          <textarea id="details" placeholder="Product Details (one per line)" required></textarea>
          <input type="number" id="maxCount" name="maxCount" placeholder="Max Count" min="1" required>
        </div>
        <div class="submit-btn-container">
          <button type="submit" id="submitBtn">Add Product</button>
        </div>
      </form>

      <h2>Product List</h2>
      <table id="productTable">
        <thead>
          <tr>
            <th>Images</th>
            <th>Name</th>
            <th>Price</th>
            <th>Max Count</th>
            <th>Action</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- ORDERS TAB -->
    <div id="orders-tab" class="tab-content">
      <h2>Order List</h2>
      <div class="order-filters">
        <select id="statusFilter">
          <option value="all">All Statuses</option>
          <option value="pending">Pending</option>
          <option value="paid">Paid</option>
          <option value="created">Created</option>
          <option value="shipped">Shipped</option>
          <option value="delivered">Delivered</option>
        </select>

        <select id="dateFilter">
          <option value="all">All Dates</option>
          <option value="today">Today</option>
          <option value="week">This Week</option>
          <option value="month">This Month</option>
        </select>

        <button onclick="applyFilters()">Apply Filters</button>
      </div>
      <div class="orders-grid" id="ordersGrid">
        <!-- Orders will be loaded here -->
      </div>
    </div>
  </div>

  <!-- NEW DELETED PRODUCTS TAB -->
  <div id="deleted-tab" class="tab-content">
    <h2>Deleted Products</h2>
    <form id="restoreForm" class="restore-form" style="display: none;" onsubmit="confirmRestore(event)">
      <h3>Restore Product</h3>

      <div class="form-grid">
        <!-- Product Name -->
        <div class="form-group">
          <label for="restore-name">Product Name</label>
          <input type="text" id="restore-name" class="form-control" placeholder="Product Name" readonly />
        </div>

        <!-- Product Price -->
        <div class="form-group">
          <label for="restore-price">Price (INR)</label>
          <input type="number" id="restore-price" class="form-control" placeholder="Price" readonly />
        </div>

        <!-- Image Preview -->
        <div class="form-group full-width">
          <label>Product Images</label>
          <div id="restore-imagePreview" class="image-grid"></div>
        </div>

        <!-- Description -->
        <div class="form-group full-width">
          <label for="restore-description">Description</label>
          <textarea id="restore-description" class="form-control" placeholder="Product Description" readonly></textarea>
        </div>

        <!-- Details -->
        <div class="form-group full-width">
          <label for="restore-details">Details</label>
          <textarea id="restore-details" class="form-control" placeholder="Product Details (one per line)"
            readonly></textarea>
        </div>
      </div>

      <div class="form-actions">
        <input type="hidden" id="restore-productId" />
        <button type="submit" class="btn btn-primary">Restore Product</button>
        <button type="button" class="btn btn-secondary" onclick="cancelRestore()">Cancel</button>
      </div>
    </form>
    <table id="deletedProductTable">
      <thead>
        <tr>
          <th>Images</th>
          <th>Name</th>
          <th>Price</th>
          <th>Deleted On</th>
          <th>Action</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <!-- DELETE MODAL -->
  <div id="deleteModal" class="modal">
    <div class="modal-content">
      <p>Are you sure you want to delete this product?</p>
      <div class="modal-buttons">
        <button class="confirm-btn" onclick="confirmDelete()">Yes</button>
        <button class="cancel-btn" onclick="closeModal()">No</button>
      </div>
    </div>
  </div>

  <script>
    // Session configuration
    const SESSION_DURATION = 6 * 60 * 60 * 1000; // 6 hours in milliseconds

    // Check authentication status
    function checkAuth() {
      const sessionExpires = localStorage.getItem('sessionExpires');

      if (localStorage.getItem('adminSession') !== 'true' ||
        !sessionExpires ||
        Date.now() > parseInt(sessionExpires)) {
        // Session expired or not logged in
        endSession();
        window.location.href = 'admin-login.html';
        return false;
      }
      return true;
    }

    // Reset session timer on user activity
    function resetSessionTimer() {
      const newExpiration = Date.now() + SESSION_DURATION;
      localStorage.setItem('sessionExpires', newExpiration.toString());
    }

    // End session (logout)
    function endSession() {
      localStorage.removeItem('adminSession');
      localStorage.removeItem('sessionExpires');
    }

    // Add logout button functionality
    function setupLogoutButton() {
      const logoutBtn = document.createElement('div');
      logoutBtn.className = 'logout-btn';
      logoutBtn.innerHTML = `
        <img class="logout-icon" src="https://cdn-icons-png.flaticon.com/512/126/126467.png" alt="Logout" onclick="logout()">
      `;
      document.querySelector('.header').appendChild(logoutBtn);
    }

    function logout() {
      endSession();
      window.location.href = 'admin-login.html';
    }

    let db;
    let productsDb;
    let editIndex = -1;
    let deleteIndex = -1;
    const table = document.querySelector("#productTable tbody");
    const modal = document.getElementById("deleteModal");

    // Initialize the database
    function initDB() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open('SenenProductsDB', 6);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          const oldVersion = event.oldVersion;

          if (oldVersion < 1) {
            const productsStore = db.createObjectStore('products', { keyPath: 'id' });
            productsStore.createIndex('byActive', 'isActive', { unique: false });
            // Add maxCount to new products
            const store = db.createObjectStore('productImages', { keyPath: ['productId', 'index'] });
            store.createIndex('byProduct', 'productId', { unique: false });
          }

          // For existing databases, we need to handle data migration
          if (oldVersion < 6) { // Increment version number
            const transaction = event.target.transaction;
            const store = transaction.objectStore('products');

            // Get all products and add maxCount field
            store.getAll().onsuccess = function (e) {
              const products = e.target.result;
              products.forEach(product => {
                if (product.maxCount === undefined) {
                  product.maxCount = 0; // Default value
                  store.put(product);
                }
              });
            };
          }
        };

        request.onsuccess = (event) => {
          productsDb = event.target.result;

          // Open orders DB
          const ordersRequest = indexedDB.open('SenenOrdersDB', 6);

          ordersRequest.onupgradeneeded = (e) => {
            const db = e.target.result;
            if (!db.objectStoreNames.contains('orders')) {
              const store = db.createObjectStore('orders', { keyPath: 'id' });
              store.createIndex('byDate', 'date', { unique: false });
              store.createIndex('byStatus', 'status', { unique: false });
            }
          };

          ordersRequest.onsuccess = (e) => {
            db = e.target.result;
            resolve();
          };

          ordersRequest.onerror = (e) => {
            reject(e.target.error);
          };
        };

        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    }

    // Show loading indicator
    function showLoading() {
      document.getElementById('loadingIndicator').style.display = 'flex';
    }

    // Hide loading indicator
    function hideLoading() {
      document.getElementById('loadingIndicator').style.display = 'none';
    }

    // Save product to IndexedDB
    async function saveProductToDB(product) {
      showLoading();
      try {
        // First save product metadata
        await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.put(product);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });

        // Delete existing images if editing
        if (editIndex > -1) {
          await new Promise((resolve, reject) => {
            const transaction = productsDb.transaction(['productImages'], 'readwrite');
            const store = transaction.objectStore('productImages');
            const index = store.index('byProduct');
            const request = index.openCursor(IDBKeyRange.only(product.id));

            request.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                if (cursor.value.imageUrl) {
                  URL.revokeObjectURL(cursor.value.imageUrl);
                }
                cursor.delete();
                cursor.continue();
              } else {
                resolve();
              }
            };
            request.onerror = () => reject(request.error);
          });
        }

        // Save each image as Blob
        for (const [index, file] of product.imageFiles.entries()) {
          await new Promise((resolve, reject) => {
            const transaction = productsDb.transaction(['productImages'], 'readwrite');
            const store = transaction.objectStore('productImages');
            const request = store.add({
              productId: product.id,
              imageBlob: file,
              imageName: file.name,
              index
            });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        }
      } finally {
        hideLoading();
      }
    }

    // Get products from IndexedDB
    async function getProductsFromDB() {
      return new Promise((resolve) => {
        const transaction = productsDb.transaction(['products'], 'readonly');
        const store = transaction.objectStore('products');
        const request = store.getAll();

        request.onsuccess = (event) => {
          const allProducts = event.target.result || [];
          // Filter active products in memory if index doesn't exist
          const activeProducts = allProducts.filter(product =>
            product.isActive !== false // Include if undefined or true
          );
          resolve(activeProducts);
        };

        request.onerror = () => resolve([]);
      });
    }
    // Get image info for a product from IndexedDB
    async function getProductImageInfo(productId) {
      return new Promise((resolve) => {
        const transaction = productsDb.transaction(['productImages'], 'readonly');
        const store = transaction.objectStore('productImages');
        const index = store.index('byProduct');
        const request = index.getAll(IDBKeyRange.only(productId));

        request.onsuccess = (event) => {
          const imageInfo = (event.target.result || [])
            .sort((a, b) => a.index - b.index)
            .map(item => {
              const url = item.imageBlob ? URL.createObjectURL(item.imageBlob) : '';
              return {
                url: url,
                name: item.imageName
              };
            });
          resolve(imageInfo);
        };

        request.onerror = () => resolve([]);
      });
    }

    // Delete product from IndexedDB
    async function deleteProductFromDB(productId) {
      showLoading();
      try {
        // First get the product
        const product = await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.get(productId);

          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });

        if (!product) {
          throw new Error('Product not found');
        }

        // Update the product to inactive
        product.isActive = false;
        product.deletedOn = new Date().toISOString();

        // Save the updated product
        await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.put(product);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });

      } finally {
        hideLoading();
      }
    }

    // Render products table with image names
    async function renderProducts() {
      showLoading();
      try {
        const products = await getProductsFromDB();
        table.innerHTML = '';

        for (const product of products) {
          const imageInfo = await getProductImageInfo(product.id);
          const imagesText = imageInfo.map(info => info.name).join(', ');

          const row = document.createElement('tr');
          row.innerHTML = `
            <td class="image-names">${imagesText}</td>
            <td>${product.name}</td>
            <td>₹${product.price}</td>
            <td>${product.maxCount}</td>
            <td>
              <div class="action-buttons">
                <button class="icon-btn edit-btn" data-id="${product.id}" title="Edit">&#9998;</button>
                <button class="icon-btn delete-btn" data-id="${product.id}" title="Delete">&#10006;</button>
              </div>
            </td>
          `;
          table.appendChild(row);

          // Add event listeners directly to the new buttons
          row.querySelector('.edit-btn').addEventListener('click', () => editProduct(product.id));
          row.querySelector('.delete-btn').addEventListener('click', () => showModal(product.id));
        }
      } finally {
        hideLoading();
      }
    }

    // Save product form handler
    async function saveProduct(e) {
      e.preventDefault();
      const name = document.getElementById('name').value;
      const price = document.getElementById('price').value;
      const description = document.getElementById('description').value;
      const details = document.getElementById('details').value.split('\n').filter(item => item.trim() !== '');
      const imageInput = document.getElementById('image');
      const maxCount = parseInt(document.getElementById('maxCount').value || 1);

      // Get the files in the order they appear in the preview
      const previewContainer = document.getElementById('imagePreview');
      const previewElements = Array.from(previewContainer.querySelectorAll('.preview-image'));
      const orderedFiles = previewElements.map(el => {
        const index = el.dataset.index;
        return imageInput.files[index];
      }).filter(Boolean);

      if (orderedFiles.length === 0) {
        alert("Please select at least one image.");
        return;
      }

      try {
        const productId = editIndex !== -1 ? editIndex : Date.now().toString();
        const newProduct = {
          id: productId,
          name,
          price,
          maxCount,
          description,
          details,
          imageFiles: orderedFiles,
          isActive: true // Default to active
        };

        await saveProductToDB(newProduct);

        document.querySelector('form').reset();
        document.getElementById('imagePreview').innerHTML = '';
        document.getElementById('submitBtn').textContent = 'Add Product';
        editIndex = -1;
        await renderProducts();
      } catch (error) {
        console.error('Error saving product:', error);
        alert('Failed to save product: ' + error.message);
      }
    }

    // Edit product
    async function editProduct(productId) {
      showLoading();
      try {
        const transaction = productsDb.transaction(['products'], 'readonly');
        const store = transaction.objectStore('products');
        const request = store.get(productId);

        request.onsuccess = async (event) => {
          const product = event.target.result;
          if (product) {
            document.getElementById('name').value = product.name;
            document.getElementById('price').value = product.price;
            document.getElementById('maxCount').value = product.maxCount;
            document.getElementById('description').value = product.description || '';
            document.getElementById('details').value = product.details ? product.details.join('\n') : '';
            document.getElementById('submitBtn').textContent = 'Update Product';
            editIndex = product.id;

            // Load images for editing
            const imageInfo = await getProductImageInfo(productId);
            const previewContainer = document.getElementById('imagePreview');
            previewContainer.innerHTML = '';

            // Create a DataTransfer object to hold the files
            const dataTransfer = new DataTransfer();

            for (const [index, info] of imageInfo.entries()) {
              // Fetch the blob to create a File object
              const response = await fetch(info.url);
              const blob = await response.blob();
              const file = new File([blob], info.name, { type: blob.type });
              dataTransfer.items.add(file);

              // Create preview
              const previewDiv = document.createElement('div');
              previewDiv.className = 'preview-image';
              previewDiv.dataset.index = index;
              previewDiv.draggable = true;

              previewDiv.innerHTML = `
                <img src="${info.url}" alt="Preview">
                <button class="remove-btn" data-index="${index}">×</button>
                <button class="move-handle" data-index="${index}">↕</button>
              `;

              previewContainer.appendChild(previewDiv);
              setupDragAndDrop(previewDiv);
            }

            // Update the file input
            const fileInput = document.getElementById('image');
            fileInput.files = dataTransfer.files;
          }
        };
      } finally {
        hideLoading();
      }
    }

    // Setup drag and drop for image reordering
    function setupDragAndDrop(element) {
      element.addEventListener('dragstart', function (e) {
        e.dataTransfer.setData('text/plain', this.dataset.index);
        this.classList.add('dragging');
      });

      element.addEventListener('dragend', function () {
        this.classList.remove('dragging');
      });
    }

    // Handle drop events for reordering
    document.getElementById('imagePreview').addEventListener('dragover', function (e) {
      e.preventDefault();
      const dragging = document.querySelector('.preview-image.dragging');
      const afterElement = getDragAfterElement(this, e.clientY);

      if (afterElement == null) {
        this.appendChild(dragging);
      } else {
        this.insertBefore(dragging, afterElement);
      }
    });

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.preview-image:not(.dragging)')];

      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;

        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Handle image removal
    document.getElementById('imagePreview').addEventListener('click', function (e) {
      if (e.target.classList.contains('remove-btn')) {
        const index = e.target.dataset.index;
        const fileInput = document.getElementById('image');
        const files = Array.from(fileInput.files);

        // Remove the file from the input
        files.splice(index, 1);

        // Create new DataTransfer object and update files
        const dataTransfer = new DataTransfer();
        files.forEach(file => dataTransfer.items.add(file));
        fileInput.files = dataTransfer.files;

        // Trigger change event to update preview
        fileInput.dispatchEvent(new Event('change'));
      }
    });

    // Handle image selection and preview
    document.getElementById('image').addEventListener('change', function (e) {
      const files = e.target.files;
      const previewContainer = document.getElementById('imagePreview');
      previewContainer.innerHTML = '';

      if (!files || files.length === 0) return;

      // Create preview for each file
      Array.from(files).forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function (e) {
          const previewDiv = document.createElement('div');
          previewDiv.className = 'preview-image';
          previewDiv.dataset.index = index;
          previewDiv.draggable = true;

          previewDiv.innerHTML = `
            <img src="${e.target.result}" alt="Preview">
            <button class="remove-btn" data-index="${index}">×</button>
            <button class="move-handle" data-index="${index}">↕</button>
          `;

          previewContainer.appendChild(previewDiv);
          setupDragAndDrop(previewDiv);
        };
        reader.readAsDataURL(file);
      });
    });

    // Show delete confirmation modal
    function showModal(productId) {
      // Remove any existing modals first
      const existingModals = document.querySelectorAll('.modal');
      existingModals.forEach(modal => modal.remove());

      deleteIndex = productId;

      // Create a fresh modal
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.id = 'deleteModal';
      modal.innerHTML = `
        <div class="modal-content">
          <p>Are you sure you want to delete this product?</p>
          <div class="modal-buttons">
            <button class="confirm-btn">Yes</button>
            <button class="cancel-btn">No</button>
          </div>
        </div>
      `;

      // Add event listeners to the new buttons
      modal.querySelector('.confirm-btn').addEventListener('click', confirmDelete);
      modal.querySelector('.cancel-btn').addEventListener('click', () => modal.remove());

      document.body.appendChild(modal);
      modal.style.display = 'flex';
    }

    // Close modal
    function closeModal() {
      deleteIndex = -1;
      const modal = document.getElementById('deleteModal');
      if (modal) modal.remove();
    }

    // Confirm delete
    async function confirmDelete() {
      if (deleteIndex !== -1) {
        showLoading();
        try {
          await deleteProductFromDB(deleteIndex);
          await renderProducts();

          // Remove the modal after successful deletion
          const modal = document.getElementById('deleteModal');
          if (modal) modal.remove();
        } catch (error) {
          console.error('Error deleting product:', error);
          alert('Failed to delete product: ' + error.message);
        } finally {
          hideLoading();
        }
      }
    }

    // ORDERS FUNCTIONS
    async function getOrdersFromDB() {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('Database not initialized'));
          return;
        }

        const transaction = db.transaction(['orders'], 'readonly');
        const store = transaction.objectStore('orders');
        const request = store.getAll();

        request.onsuccess = (event) => {
          resolve(event.target.result || []);
        };

        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    }

    async function getOrderDetails(orderId) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('Database not initialized'));
          return;
        }

        const transaction = db.transaction(['orders'], 'readonly');
        const store = transaction.objectStore('orders');
        // Ensure consistent numeric ID handling
        const request = store.get(Number(orderId));

        request.onsuccess = (event) => {
          const result = event.target.result;
          if (!result) {
            reject(new Error(`Order with ID ${orderId} not found`));
          } else {
            resolve(result);
          }
        };

        request.onerror = (event) => {
          reject(new Error('Database error: ' + event.target.error));
        };
      });
    }

    async function getProductDetails(productId) {
      return new Promise((resolve) => {
        const transaction = productsDb.transaction(['products'], 'readonly');
        const store = transaction.objectStore('products');
        const request = store.get(productId);

        request.onsuccess = (event) => {
          resolve(event.target.result || null);
        };

        request.onerror = () => resolve(null);
      });
    }

    async function getProductImages(productId) {
      return new Promise((resolve) => {
        const transaction = productsDb.transaction(['productImages'], 'readonly');
        const store = transaction.objectStore('productImages');
        const index = store.index('byProduct');
        const request = index.getAll(IDBKeyRange.only(productId));

        request.onsuccess = (event) => {
          const images = (event.target.result || [])
            .sort((a, b) => a.index - b.index)
            .map(item => item.imageBlob ? URL.createObjectURL(item.imageBlob) : '');
          resolve(images);
        };

        request.onerror = () => resolve([]);
      });
    }

    async function updateOrderStatus(orderId, newStatus) {
      return new Promise((resolve, reject) => {
        if (!db) {
          reject(new Error('Database not initialized'));
          return;
        }

        const transaction = db.transaction(['orders'], 'readwrite');
        const store = transaction.objectStore('orders');

        // Convert orderId to number for consistency
        const numericOrderId = typeof orderId === 'string' ? Number(orderId) : orderId;

        const getRequest = store.get(numericOrderId);

        getRequest.onsuccess = (event) => {
          const order = event.target.result;
          if (!order) {
            reject(new Error(`Order with ID ${numericOrderId} not found`));
            return;
          }

          order.status = newStatus;
          order.lastUpdated = new Date().toISOString();

          const putRequest = store.put(order);

          putRequest.onsuccess = () => resolve(order);
          putRequest.onerror = (event) => reject(event.target.error);
        };

        getRequest.onerror = (event) => reject(event.target.error);
      });
    }

    async function applyFilters() {
      const statusFilter = document.getElementById('statusFilter').value;
      const dateFilter = document.getElementById('dateFilter').value;

      showLoading();
      try {
        const allOrders = await getOrdersFromDB();
        let filteredOrders = [...allOrders];

        // Apply status filter
        if (statusFilter !== 'all') {
          filteredOrders = filteredOrders.filter(order => order.status === statusFilter);
        }

        // Apply date filter
        const now = new Date();
        if (dateFilter !== 'all') {
          filteredOrders = filteredOrders.filter(order => {
            const orderDate = new Date(order.date);

            if (dateFilter === 'today') {
              return orderDate.toDateString() === now.toDateString();
            } else if (dateFilter === 'week') {
              const startOfWeek = new Date(now);
              startOfWeek.setDate(now.getDate() - now.getDay());
              return orderDate >= startOfWeek;
            } else if (dateFilter === 'month') {
              return orderDate.getMonth() === now.getMonth() &&
                orderDate.getFullYear() === now.getFullYear();
            }
            return true;
          });
        }

        renderFilteredOrders(filteredOrders);
      } catch (error) {
        console.error('Error applying filters:', error);
        alert('Failed to apply filters: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    async function renderFilteredOrders(orders) {
      const ordersGrid = document.getElementById('ordersGrid');
      ordersGrid.innerHTML = '';

      if (orders.length === 0) {
        ordersGrid.innerHTML = '<p>No orders match the selected filters</p>';
        return;
      }

      // Sort orders by date (newest first)
      orders.sort((a, b) => new Date(b.date) - new Date(a.date));

      for (const order of orders) {
        const orderCard = document.createElement('div');
        orderCard.className = 'order-card';

        const statusClass = `status-${order.status || 'pending'}`;
        const amount = (order.price || 0) * (order.quantity || 1);

        orderCard.innerHTML = `
          <div class="order-header">
            <div>
              <div class="order-id">Order #${order.id}</div>
              <div class="order-date">${new Date(order.date).toLocaleString()}</div>
            </div>
            <div class="order-status ${statusClass}">${order.status || 'pending'}</div>
          </div>
          <div class="order-details">
            <p><strong>Product:</strong> ${order.productId}</p>
            <p><strong>Customer:</strong> ${order.fullName}</p>
            <p><strong>Amount:</strong> ₹${amount.toFixed(2)}</p>
          </div>
          <div class="order-actions">
            <select class="status-select" data-order-id="${order.id}">
              <option value="pending" ${order.status === 'pending' ? 'selected' : ''}>Pending</option>
              <option value="paid" ${order.status === 'paid' ? 'selected' : ''}>Paid</option>
              <option value="created" ${order.status === 'created' ? 'selected' : ''}>Order Created</option>
              <option value="shipped" ${order.status === 'shipped' ? 'selected' : ''}>Shipped</option>
              <option value="delivered" ${order.status === 'delivered' ? 'selected' : ''}>Delivered</option>
            </select>
            <button class="view-btn" data-order-id="${order.id}" title="View Details">
              <img src="https://cdn-icons-png.flaticon.com/512/11502/11502607.png" alt="View" style="width:20px;height:20px;">
            </button>
          </div>
        `;

        ordersGrid.appendChild(orderCard);
      }
    }

    async function renderOrders() {
      showLoading();
      try {
        const orders = await getOrdersFromDB();
        await renderFilteredOrders(orders);
      } catch (error) {
        console.error('Error loading orders:', error);
        document.getElementById('ordersGrid').innerHTML = `<p>Error loading orders: ${error.message}</p>`;
      } finally {
        hideLoading();
      }
    }

    async function changeOrderStatus(orderId, newStatus) {
      showLoading();
      try {
        // Ensure orderId is treated consistently (as number)
        const numericOrderId = Number(orderId);
        await updateOrderStatus(numericOrderId, newStatus);
        await renderOrders(); // Refresh the orders list
      } catch (error) {
        console.error('Error updating order status:', error);
        alert('Failed to update order status: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    function getStatusClass(status) {
      switch (status) {
        case 'pending': return 'status-pending';
        case 'created': return 'status-created';
        case 'shipped': return 'status-shipped';
        case 'delivered': return 'status-delivered';
        default: return 'status-pending';
      }
    }

    // Function to get deleted products from IndexedDB
    async function getDeletedProductsFromDB() {
      return new Promise((resolve) => {
        const transaction = productsDb.transaction(['products'], 'readonly');
        const store = transaction.objectStore('products');
        const request = store.getAll();

        request.onsuccess = (event) => {
          const allProducts = event.target.result || [];
          // Filter inactive products in memory
          const deletedProducts = allProducts.filter(product => product.isActive === false);
          resolve(deletedProducts);
        };

        request.onerror = () => resolve([]);
      });
    }

    // Function to render deleted products
    async function renderDeletedProducts() {
      showLoading();
      try {
        const products = await getDeletedProductsFromDB();
        const tableBody = document.querySelector("#deletedProductTable tbody");
        tableBody.innerHTML = '';

        for (const product of products) {
          const imageInfo = await getProductImageInfo(product.id);
          const imagesText = imageInfo.map(info => info.name).join(', ');

          tableBody.innerHTML += `
            <tr>
              <td class="image-names">${imagesText}</td>
              <td>${product.name}</td>
              <td>₹${product.price}</td>
              <td>${new Date(product.deletedOn).toLocaleString()}</td>
              <td>
                <div class="action-buttons">
                  <button class="icon-btn" onclick="showRestoreForm('${product.id}')" title="Restore">&#8634;</button>
                </div>
              </td>
            </tr>`;
        }
      } finally {
        hideLoading();
      }
    }

    // Function to restore a product
    async function restoreProduct(productId) {
      showLoading();
      try {
        // First get the product
        const product = await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.get(productId);

          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });

        if (!product) {
          throw new Error('Product not found');
        }

        // Update the product to active
        product.isActive = true;
        delete product.deletedOn;

        // Save the updated product
        await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.put(product);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });

        // Refresh both tables
        await renderProducts();
        await renderDeletedProducts();

      } catch (error) {
        console.error('Error restoring product:', error);
        alert('Failed to restore product: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    // Function to show restore form with product details
    async function showRestoreForm(productId) {
      showLoading();
      try {
        // Get product details
        const product = await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readonly');
          const store = transaction.objectStore('products');
          const request = store.get(productId);

          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });

        if (!product) {
          throw new Error('Product not found');
        }

        // Get product images
        const imageInfo = await getProductImageInfo(productId);

        // Populate form
        document.getElementById('restore-name').value = product.name;
        document.getElementById('restore-price').value = product.price;
        document.getElementById('restore-description').value = product.description || '';
        document.getElementById('restore-details').value = product.details ? product.details.join('\n') : '';
        document.getElementById('restore-productId').value = product.id;

        // Show image previews
        const previewContainer = document.getElementById('restore-imagePreview');
        previewContainer.innerHTML = '';

        for (const [index, info] of imageInfo.entries()) {
          const previewDiv = document.createElement('div');
          previewDiv.className = 'preview-image';
          previewDiv.innerHTML = `
            <img src="${info.url}" alt="Preview">
          `;
          previewContainer.appendChild(previewDiv);
        }

        // Hide table and show form
        document.getElementById('deletedProductTable').style.display = 'none';
        document.getElementById('restoreForm').style.display = 'block';

      } catch (error) {
        console.error('Error loading product for restore:', error);
        alert('Failed to load product: ' + error.message);
      } finally {
        hideLoading();
      }
    }

    // Function to cancel restore
    function cancelRestore() {
      document.getElementById('restoreForm').style.display = 'none';
      document.getElementById('deletedProductTable').style.display = 'table';
    }

    // Function to handle restore confirmation
    function confirmRestore(e) {
      e.preventDefault();

      // Hide any existing modals first
      const existingModals = document.querySelectorAll('.modal');
      existingModals.forEach(modal => modal.remove());

      // Create and show confirmation modal
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'flex';
      modal.id = 'restoreConfirmModal'; // Add ID for easy reference
      modal.innerHTML = `
        <div class="modal-content">
          <p>Are you sure you want to restore this product?</p>
          <div class="modal-buttons">
            <button class="confirm-btn" onclick="performRestore()">Yes</button>
            <button class="cancel-btn" onclick="document.getElementById('restoreConfirmModal').remove()">No</button>
          </div>
        </div>
      `;

      document.body.appendChild(modal);
    }


    // Function to actually perform the restore
    async function performRestore() {
      const productId = document.getElementById('restore-productId').value;

      showLoading();
      try {
        // First get the product
        const product = await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.get(productId);

          request.onsuccess = (event) => resolve(event.target.result);
          request.onerror = (event) => reject(event.target.error);
        });

        if (!product) {
          throw new Error('Product not found');
        }

        // Update the product to active
        product.isActive = true;
        delete product.deletedOn;

        // Save the updated product
        await new Promise((resolve, reject) => {
          const transaction = productsDb.transaction(['products'], 'readwrite');
          const store = transaction.objectStore('products');
          const request = store.put(product);

          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });

        // Hide the modal
        const modal = document.getElementById('restoreConfirmModal');
        if (modal) modal.remove();

        // Reset the form and show table
        cancelRestore();

        // Refresh both tables
        await renderProducts();
        await renderDeletedProducts();

      } catch (error) {
        console.error('Error restoring product:', error);
        alert('Failed to restore product: ' + error.message);
      } finally {
        hideLoading();
      }
    }
    // Tab switching function
    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');

      // Update active content
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(`${tabName}-tab`).classList.add('active');

      // Load appropriate data
      if (tabName === 'orders') {
        renderOrders();
      } else if (tabName === 'deleted') {
        renderDeletedProducts();
      } else if (tabName === 'products') {
        renderProducts();
      }
    }

    // Event delegation for dynamic elements
    document.addEventListener('change', async function (event) {
      // Handle status change specifically for select elements
      if (event.target.classList.contains('status-select')) {
        const orderId = event.target.getAttribute('data-order-id');
        const newStatus = event.target.value;
        await changeOrderStatus(orderId, newStatus);
      }
    });

    document.addEventListener('click', async function (event) {
      // Handle view details click on the eye icon or its parent
      if (event.target.classList.contains('view-btn') ||
        (event.target.parentElement && event.target.parentElement.classList.contains('view-btn'))) {
        const orderId = event.target.getAttribute('data-order-id') ||
          event.target.parentElement.getAttribute('data-order-id');
        // Redirect to order-details.html with the order ID
        window.location.href = `order-details.html?id=${orderId}`;
      }
    });

    // Initialize the application
    window.onload = function () {
      if (!checkAuth()) return;

      // Set up activity listeners to reset session timer
      document.addEventListener('mousemove', resetSessionTimer);
      document.addEventListener('keypress', resetSessionTimer);
      document.addEventListener('click', resetSessionTimer);

      // Add logout button
      setupLogoutButton();

      // Initialize the database and render products
      initDB().then(() => {
        renderProducts();
      }).catch(error => {
        console.error('Initialization error:', error);
        alert('Failed to initialize application: ' + error.message);
      });
    };
  </script>
</body>

</html>